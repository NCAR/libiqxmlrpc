/*! \file */
#ifndef _libiqnet_ssl_lib_h_
#define _libiqnet_ssl_lib_h_

#include <openssl/ssl.h>
#include <stdexcept>

namespace iqnet
{

namespace ssl
{
  class Ctx;

  //! Global SSL context.
  extern Ctx* ctx;

  class exception;
  class not_initialized;
  class io_error;
  class need_write;
  class need_read;
  
  //! Throws concrete SSL IO subsystem's exception.
  void throw_io_exception( SSL*, int ret );
};

  
//! SSL context class. Initializes SSL library.
class ssl::Ctx {
  static bool initialized;
  SSL_CTX* ctx;
  
public:
  static Ctx* client_server( const std::string& cert_path, const std::string& key_path );
  static Ctx* server_only( const std::string& cert_path, const std::string& key_path );
  static Ctx* client_only();

  ~Ctx();

  SSL_CTX* context() { return ctx; }
  
private:
  Ctx( const std::string&, const std::string&, bool init_client );
  Ctx();

  void init_library();
};


//! Exception class to wrap errors generated by openssl library.
class ssl::exception: public std::exception {
  unsigned long ssl_err;
  std::string msg;

public:
  exception() throw();
  explicit exception( unsigned long ssl_err ) throw();
  exception( const std::string& msg ) throw();
  virtual ~exception() throw() {}

  const char*   what() const throw() { return msg.c_str(); }
  unsigned long code() const throw() { return ssl_err; }
};


class ssl::not_initialized: public ssl::exception {
public:
  not_initialized():
    exception( "Libiqnet::ssl not initialized." ) {}
};


class ssl::io_error: public ssl::exception {
public:
  io_error( int err ):
    exception( err ) {}
};


class ssl::need_write: public ssl::io_error {
public:
  need_write():
    io_error( SSL_ERROR_WANT_WRITE ) {}
};


class ssl::need_read: public ssl::io_error {
public:
  need_read():
    io_error( SSL_ERROR_WANT_READ ) {}
};

};


#endif
