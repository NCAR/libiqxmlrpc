/*! \file */
#ifndef _libiqnet_ssl_lib_h_
#define _libiqnet_ssl_lib_h_

#include <openssl/ssl.h>
#include <stdexcept>

namespace iqnet
{
  //! SSL infrastructure
  namespace ssl
  {
    class Ctx;
  
    //! Global SSL context.
    /*! One must initialize it with appropriate ssl::Ctx 
        object before using iqnet's SSL code.
        \see ssl::Ctx
    */
    extern Ctx* ctx;
  
    class exception;
    class not_initialized;
    class connection_close;
    class io_error;
    class need_write;
    class need_read;
    
    //! Throws concrete SSL IO subsystem's exception.
    void throw_io_exception( SSL*, int ret );
  };
};


//! SSL context class. Initializes SSL library.
/*! 
  \code
  using namespace iqnet;
  ssl::ctx = ssl::Ctx::client_server( "/path/to/cert", "/path/to/key" );
  //...
  \endcode
*/
class iqnet::ssl::Ctx {
  static bool initialized;
  SSL_CTX* ctx;
  
public:
  static Ctx* client_server( const std::string& cert_path, const std::string& key_path );
  static Ctx* server_only( const std::string& cert_path, const std::string& key_path );
  static Ctx* client_only();

  ~Ctx();

  SSL_CTX* context() { return ctx; }
  
private:
  Ctx( const std::string&, const std::string&, bool init_client );
  Ctx();

  void init_library();
};


//! Exception class to wrap errors generated by openssl library.
class iqnet::ssl::exception: public std::exception {
  unsigned long ssl_err;
  std::string msg;

public:
  exception() throw();
  explicit exception( unsigned long ssl_err ) throw();
  exception( const std::string& msg ) throw();
  virtual ~exception() throw() {}

  const char*   what() const throw() { return msg.c_str(); }
  unsigned long code() const throw() { return ssl_err; }
};


class iqnet::ssl::not_initialized: public ssl::exception {
public:
  not_initialized():
    exception( "Libiqnet::ssl not initialized." ) {}
};


class iqnet::ssl::connection_close: public ssl::exception {
  bool clean;
public:
  connection_close( bool clean_ ): 
    exception( "Connection has been closed." ),
    clean(clean_) {}
      
  bool is_clean() const { return clean; }
};


class iqnet::ssl::io_error: public ssl::exception {
public:
  io_error( int err ):
    exception( err ) {}
};


class iqnet::ssl::need_write: public ssl::io_error {
public:
  need_write():
    io_error( SSL_ERROR_WANT_WRITE ) {}
};


class iqnet::ssl::need_read: public ssl::io_error {
public:
  need_read():
    io_error( SSL_ERROR_WANT_READ ) {}
};


#endif
