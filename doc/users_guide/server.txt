% vim: ft=viki:tw=78:noet

* Writing Server
#OPT: id=WritingServer
#LIST plain! sub!: toc

** Defining Methods

#IDX: iqxmlrpc::Method ;

A common way implementing server methods is inherit iqxmlrpc::Method class and
customize it's __execute__ virtual function. The execute method accepts two
parameters: an STL vector that contains input arguments packaged into Value
objects and a reference to Value object that will be sent to a caller as a
result of operation.

Following example illustrates trivial method returning sum of two integers.
#Code id=sum_method syntax=c++ <<EOC
#include <libiqxmlrpc/method.h>

class Sum: public iqxmlrpc::Method {
	void
	execute(const Param_list& params, Value& result)
	{
		result = params[0].get_int() + params[1].get_int();
	}
};
EOC

*** Reporting Errors

The code in previous example does not contain checks about operation
preconditions, e.g. "array of input parameters must contain exactly two
elements of integer type" in this case. Library, surely will report a error in
case of violation of __some__ of these conditions, but obviously it's response
won't be as much informative as it could be. Let's correct that omission.
#IDX: iqxmlrpc::Fault ;
#Code id=sum_method2 syntax=c++ <<EOC
void
Sum::execute(const Param_list& params, Value& result)
{
	if (params.size() != 2 || 
	    !params[0].is_int() ||
	    !params[1].is_int())
		throw Fault(123, "Array of two integers required.");

	result = params[0].get_int() + params[1].get_int();
}
EOC

 !!! Throwing iqxmlrpc::Fault exception make server generate standard fault
 response with error code and message specified by user.  Actually, server
 catch up all exceptions from users' code, but throwing Fault is the only way
 to get control over error code and message that will be placed in response.

** Configure Server

__TBD__

*** Defining Execution Strategy

Library suggests two ways of request execution:
 * Synchronous execution
 * Execution by a pool of threads

With the first way all requests are executed in the same thread that accepts
connections and parses incoming packages. The second way makes main thread do
deal with networking and XML parsing, while the actual execution of server
methods is being performed withing a pool of threads.

User may configure server with particular execution strategy depending on his
personal demands.

The constructors of server classes accept a pointer to an object of abstract
type iqxmlrpc::Executor_factory_base. A server creates executor object for
each request it receives using executor factory. Concrete type of executor
factory defines execution strategy used by a server.

An example below demonstrates how one can build appropriate execution strategy
depending on specified number of threads parameter.

#IDX iqxmlrpc::Serial_executor_factory
#IDX iqxmlrpc::Pool_executor_factory
#Code id=exec_factory syntax=c++ <<EOC
#include <libiqxmlrpc/libiqxmlrpc.h>
#include <libiqxmlrpc/executor.h>

iqxmlrpc::Executor_factory_base*
build_executor_factory(unsigned num_threads)
{
	if (num_threads > 1)
		return new iqxmlrpc::Pool_executor_factory(num_threads);

	return new iqxmlrpc::Serial_executor_factory;
}
EOC

 !!! Please note that server object does not grab ownership over execution
 factory. So one ought to take care of its destruction. The best decision here
 is to place executor factory into a smart pointer.

*** Defining Underlying Transport

There is iqxmlrpc::Server class that can be used for server creation. It has
two offsprings -- __Http_server__ and __Https_server__. They ease creation of
server objects with specific underlying transport.

The following example demonstrates creation of both HTTP and HTTPS servers
depending on users' needs.

#IDX: iqxmlrpc::Http_server ;
#IDX: iqxmlrpc::Https_server ;
#IDX: HTTP ; HTTPS ;

#Code id=create_server syntax=c++ <<EOC
#include <boost/optional.hpp>
#include <libiqxmlrpc/libiqxmlrpc.h>
#include <libiqxmlrpc/http_server.h>
#include <libiqxmlrpc/https_server.h>

struct SSLConfig {
	std::string cert_file;
	std::string privkey_file;
};

typedef boost::optional<SSLConfig> OptSSLConfig;

iqxmlrpc::Server*
create_server(int port, Executor_factory_base* ef, const OptSSLConfig& ssl)
{
	if (ssl) {
		using iqnet::ssl::ctx;
		using iqnet::ssl::Ctx;

		ctx = Ctx::server_only(ssl->cert_file, ssl->privkey_file);
		return new Https_server(port, ef);
	}

	return new iqxmlrpc::Http_server(port, ef);
}
EOC

** Server Sample

#IDX: Server Sample ;
#Code id=server_sample syntax=c++ <<EOC
#include <iostream>
#include <libiqxmlrpc/libiqxmlrpc.h>
#include <libiqxmlrpc/http_server.h>

// Simple method that just returns back first input parameter
class Echo: public iqxmlrpc::Method {
public:
  void execute(const iqxmlrpc::Param_list& params, iqxmlrpc::Value& retval)
  {
    if (params.empty())
      retval = 0;
    else
      retval = params[0];
  }
};

int main()
{
  int port = 3344;

  iqxmlrpc::Serial_executor_factory ef;
  iqxmlrpc::Http_server server(port, &ef);

  iqxmlrpc::register_method<Echo>(server, "echo");

  // optional settings
  server.log_errors( &std::cerr );
  server.enable_introspection();
  server.set_max_request_sz(1024*1024);

  // start server
  server.work();
}
EOC
