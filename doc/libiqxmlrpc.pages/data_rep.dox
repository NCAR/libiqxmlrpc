/*!
\page data_rep Data representation

- \ref value_types
- \ref value_usage
*/


/*!
\page value_types Data types
XML-RPC (http://www.xmlrpc.com) standard assumes following data types to use.

- \b Scalars:
  - string
  - integer (four bytes)
  - boolean
  - double
  - datetime (ISO8601)
  - base64
- \b Compond \b types:
  - array
  - struct

\todo Types datetime and base64 are not supported in libiqxmlrpc yet.

Library maps each XML-RPC type into a stand-alone class. Here is a piece of 
code which declares libiqxmlrpc data type classes (value_type.h):
\dontinclude value_type.h
\skip namespace
\skip iqxmlrpc
\until }

As you can see, all scalar type classes are just an instance of template
iqxmlrpc::Scalar.

\section array_usage Array's usage
iqxmlrpc::Array represents XML-RPC array data type. One can insert an array's
member of any data type to the end of array.

\code
  Array a;
  // insert data into array
  a.push_back( 1 );
  a.push_back( "Hello World!" );
  
  // access the value
  std::cout 
    << "a is of size: " << a.size()          << std::endl
    << "a[0] = "        << a[0].get_int()    << std::endl
    << "a[1] = "        << a[1].get_string() << std::endl;

  // STL's assign analog
  std::vector<double> v;
  // filling v...
  a.assign( v.begin(), v.end() );
\endcode

Array::push_back() takes object of iqxmlrpc::Value class as an argument.
Hence class Value has constructors which can take std::string, int, double, ... 
as an argument, one can transfer std::string or int rather then Value as 
argument for push_back().

Arrays's operator [] returns a reference to iqxmlrpc::Value class' object.
If one will try access to out of bound element of array then exception
iqxmlrpc::Array::Out_of_range will be thrown.

\see \ref value_usage 

\section struct_usage Struct's usage
iqxmlrpc::Struct represents data structures. It holds objects of 
iqxmlrpc::Value class as structure members.

\code
  Struct s;
  
  // insert data to a struct
  s.insert( "author", "Gabriel Garcia Marques" );
  s.insert( "title", "One Hundred Years of Solitude" );
  s.insert( "pages", 464 );
\endcode

Struct::insert() takes struct's field name as first argument and object 
of iqxmlrpc::Value class as second argument. As soon as Value has constructors 
which can take std::string, int, double, ... as an argument, one can transfer 
std::string or int rather then Value as argument for insert().

\code
  // check if struct contains specific members
  // and access an actual value
  if( s.has_field( "price" )
    std::cout << s["price"].get_double() << std::endl;
\endcode

Struct::operator [] returns a reference to iqxmlrpc::Value object.
You can use Struct::has_field function to find out whether structure has 
specific field. If anyone will try to access unexistent field then
iqxmlrpc::Struct::No_field would be thrown.

\see \ref value_usage
*/


/*! 
\page value_usage Manipulating with values
\section value_class iqxmlrpc::Value class
Users of the library should use objects of class iqxmlrpc::Value 
to store/transfer their values. Value objects can contain values of various 
types defined in libiqxmlrpc and represent an interface for 
retrieving/storing value of particular type as well as special methods 
specific for iqxmlrpc::Array and iqxmlrpc::Struct only.

\see \ref value_types

\section value_create Creating a value
One can assign Value object with following type of argument:
  - int
  - bool
  - double
  - std::string
  - const char*
  - iqxmlrpc::Array
  - iqxmlrpc::Struct
  
In all cases new object of class inherited from iqxmlrpc::Value_type will be
created and placed under control of Value object.

\b Example:
\code
  Value v1 = 10;
  Value v2 = true;
  Value v3 = 0.44;
  Value v4 = "C string";
  Value v5 = Array();
  Value v6 = Struct();
  
  v5.push_back( true );
  v6.insert( "test_item", 0.33 );
\endcode

\section value_convert Accessing the values
One can convert Value to a concrete type:
\code
  int          i = v1;
  bool         b = v2;
  double       d = v3;
  std::string  s = v4;
  bool        b2 = v5[0];
  double      d2 = v6["test_item"];
\endcode

When many ambiguous conversions are possible use Value::get_xxx() functions:
\code
  try 
  {
    std::cout 
      << v1.get_int()     << std::endl
      << v2.get_bool()    << std::endl
      << v3.get_double()  << std::endl
      << v4.get_string()  << std::endl
      << v5[0].get_bool() << std::endl
      << v6["test_item"].get_double() << std::endl
  }
  catch( const iqxmlrpc::Value::Bad_cast& e )
  {
    std::cerr << e.what() << std::endl;
  }
\endcode

As you can see in listing above, library throws iqxmlrpc::Value::Bad_cast on
incorrect types conversion try.

It is also possible to check a correctness of type explicitly:
\code
  if( v1.is_int() )
    std::cout << v1.get_int() << std::endl;
  else
    std::cerr << "int is expected." << std::endl;
\endcode

\section value_access_array Accessing Arrays and Structs
iqxmlrpc::Value provides several methods to access a Value as it would be
Array or Struct. These methods mostly have the same name as appropriate names
of Array and Struct classes. E.g. Value::push_back calls Array::push_back 
and so on. So one can call some (not all) array or struct specific methods 
using Value's interface:
\code
  Value v = Array();
  v.push_back( false );
  v.push_back( Struct() );
  v[1].insert( "test_item", 0.33 );
\endcode

One can also get access to actual array or struct by calling 
iqxmlrpc::Value::the_array() or iqxmlrpc::Value::the_struct().

\b Example:
\code
  Value v = Struct();
  // ...
  v.the_struct().clear();
\endcode
*/
