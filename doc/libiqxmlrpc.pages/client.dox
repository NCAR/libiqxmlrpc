/*!
\page client_prog Writing XML-RPC client
It is pretty easy to use libiqxmlrpc on client side. One must create instance of
iqxmlrpc::Client class with corresponding client's transport as template 
parameter and to call an \b execute() method each time, when remote procedure 
execution is needed.

Each time the user invokes \e Client<X>::execute(), a new connection is created 
and HTTP request/response pair is passed through the network. When server 
response was received, client closes the connection.

Both HTTP and HTTPS clients are implemented using non-blocking sockets. It 
allows to set a timeout on network communications (see 
iqxmlrpc::Client::set_timeout).

Class iqxmlrpc::Client inherits iqxmlrpc::Client_base. So we can create 
relatively transport-independent code:
\include client_general.h

\subsection client_examples Examples
- \ref http_client
- \ref https_client

\subsection exceptions Caring about exceptions
User must care about exceptions, which library can throw.
These exceptions are:
 - iqnet::network_error<br>
This exception will be thrown in case of some errors found by networking code.
 
 - iqxmlrpc::Exception<br>
This class is a base class for many exception related to XML-RPC.<p>
   - iqxmlrpc::Client_timeout - timeout set by Client::set_timeout has been expired;
   - iqxmlrpc::Fault - fault response has been received.

User can also check if received response is an XML-RPC Fault Response by 
using iqxmlrpc::Response::is_fault member function or just try to get access
to Response's content (iqxmlrpc::Response::value). In second case the 
iqxmlrpc::Fault exception would be thrown if it was a Fault Reponse.
*/
