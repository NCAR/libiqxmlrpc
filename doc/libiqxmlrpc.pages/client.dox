/*!
\page client_prog Writing XML-RPC client
It is pretty easy to use libiqxmlrpc on client side. One must create instance of
iqxmlrpc::Client class with corresponding client's transport as template 
parameter and to call an \b execute() method each time, when remote procedure 
execution is needed.

Each time the user invokes \e Client<X>::execute(), a new connection is created 
unless user has turned on keep-alive connection via iqxmlrpc::Client::set_keep_alive().
Then HTTP request/response pair is passed through the network. When server 
response was received, client closes the connection (by default) or leaves
it open (in case of keep-alive connection type).

User can specify client's connection timeout via iqxmlrpc::Client::set_timeout().
In this case client's transport would use non-blocking sockets. If no timeout
or a negative timeout were specified then client's transport would use blocking
sockets.

Class iqxmlrpc::Client inherits iqxmlrpc::Client_base. So we can create 
relatively transport-independent code:
\include client_general.h

\subsection client_examples Examples
- \ref http_client
- \ref https_client

\subsection exceptions Caring about exceptions
User must care about exceptions, which library can throw.
These exceptions are:
 - iqnet::network_error<br>
This exception will be thrown in case of some errors found by networking code.
 
 - iqxmlrpc::Exception<br>
This class is a base class for many exception related to XML-RPC.<p>
   - iqxmlrpc::Client_timeout - timeout set by Client::set_timeout has been expired;
   - iqxmlrpc::Fault - fault response has been received.

User can also check if received response is an XML-RPC Fault Response by 
using iqxmlrpc::Response::is_fault member function or just try to get access
to Response's content (iqxmlrpc::Response::value). In second case the 
iqxmlrpc::Fault exception would be thrown if it was a Fault Reponse.
*/
