/*! 
\page server_prog Writing XML-RPC server
To create XML-RPC server application using libiqxmlrpc, follow the next steps:
 -# Define server behaviour by creating the a of iqxmlrpc::Method children 
    classes.
 -# Define an execution policy (i.e. to define whether to use serial execution 
    model or multithreaded one).
 -# Create an instance of iqxmlrpc::Server class.
 -# Register those method classes with server object.
 -# Run iqxmlrpc::Server::work() parametrized with concrete transport class.

Library implements two transports: \b HTTP and \b HTTPS. To activate an 
appropriate transports, one must parametrize iqxmlrpc::Server::work() method 
with one of following classes: Http_server_connection or Https_server_connection. 

\note You should initialize underlying OpenSSL library too before using HTTPS.
See examples also \ref https_server_ex.

\b Next \b reading
- \ref define_server_behaviour
- \ref execution_model
- \ref http_server
- \ref https_server
*/


/*!
\page define_server_behaviour Defining server behaviour
\subsection define_server_methods Define server methods
An actual server behaviour is defined by number of server methods. An 
application developer is responsible for creation of such methods' set.
Each server method is a class, which must be a child of iqxmlrpc::Method class.
One must at least define abstract method iqxmlrpc::Method::execute in user's
class.

\include server_general.h

\subsection fault_response Fault responses
When user throws libiqxml::Fault exception from execute method, library forms 
fault response to a remote client as proposed by XML-RPC standard. 
So feel free to throw iqxmlrpc::Fault object or its childs when you want to 
inform remote user about method's fault. User also responsible for assigning 
any sense to the error codes, transmited with fault response.

Library uses <i>fault code -1</i> to indicate error occured/find within 
server's code.


\subsection register_methods Register the methods
Method must be registered on iqxmlrpc::Server object to be able to execute.<br>
See an example:

\dontinclude http_server.cc
\skipline server->register_method

Template parameter (Get_weather, here) is an actual method's class name. And 
string parameter of fuction specifies method's name to use in XML-RPC.
*/


/*!
\page execution_model Libiqxmlrpc execution model
iqxmlrpc::Server parses XML-RPC requests and creates an object of appropriate 
class for each requested method. After that, Server starts method's execution 
through iqxmlrpc::Executor object, which is created by Server using
iqxmlrpc::Executor_fabric_base.

Since user must specify concrete type of Executor_fabric during Server's 
construction, thus, he defines Server's <b>method execution policy</b>. E.g.
specific Executor_fabric can create Executor's children, which run methods in 
new thread (Threaded_executor in future).

However, there is thing, which any Executor object can not change. It is that
fact that all network communications are working in the Server object's thread.
In other words, all network IO is performed in one thread independently of 
used execution policy.
*/
