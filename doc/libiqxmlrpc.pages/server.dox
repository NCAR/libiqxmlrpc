/*! 
\page server_prog Writing XML-RPC server
To create XML-RPC server application using libiqxmlrpc, follow the next steps:
 -# Define server behaviour by creating the a of iqxmlrpc::Method children 
    classes.
 -# Define an execution policy (i.e. to define whether to use serial execution 
    model or multithreaded one).
 -# Create an instance of iqxmlrpc::Server class.
 -# Register those method classes with server object.
 -# Run iqxmlrpc::Server::work() parametrized with concrete transport class.

Library implements two transports: \b HTTP and \b HTTPS. To activate an 
appropriate transports, one must parametrize iqxmlrpc::Server::work() method 
with one of following classes: Http_server_connection or Https_server_connection. 

\note You should initialize underlying OpenSSL library too before using HTTPS.
See examples also \ref https_server_ex.

\b Next \b reading
- \ref define_server_behaviour
- \ref execution_model
- \ref introspection
- \ref fci_conformance

\b Examples
- \ref http_server
- \ref https_server
- \ref http_server_thr
*/


/*!
\page define_server_behaviour Defining server behaviour
\subsection define_server_methods Define server methods
An actual server behaviour is defined by number of server methods. An 
application developer is responsible for creation of such methods' set.
Each server method is a class, which must be a child of iqxmlrpc::Method class.
One must at least define abstract method iqxmlrpc::Method::execute in user's
class.

\include server_general.h

\subsection fault_response Fault responses
When user throws libiqxml::Fault exception from execute method, library forms 
fault response to a remote client as proposed by XML-RPC standard. 
So feel free to throw iqxmlrpc::Fault object or its childs when you want to 
inform remote user about method's fault. User also responsible for assigning 
any sense to the error codes, transmited with fault response.

Library uses <i>fault code -1</i> to indicate error occured/find within 
server's code.


\subsection register_methods Register the methods
Method must be registered on iqxmlrpc::Server object to be able to execute.<br>
See an example:

\dontinclude tests/http_server.cc
\skipline server->register_method

Template parameter (Get_weather, here) is an actual method's class name. And 
string parameter of fuction specifies method's name to use in XML-RPC.
*/


/*!
\page execution_model An execution model of Libiqxmlrpc
iqxmlrpc::Server parses XML-RPC requests and creates an object of appropriate 
class for each requested method. After that, Server starts method's execution 
through iqxmlrpc::Executor object, which is created by Server using
iqxmlrpc::Executor_fabric_base.

Since user must specify concrete type of Executor_fabric during Server's 
construction, thus, he defines Server's <b>method execution policy</b>. E.g.
specific Executor_fabric can create Executor's children, which run methods in 
new thread (Threaded_executor in future).

\note Note that there is thing, which any Executor object can not change. 
It is that fact that all network communications are working in the Server 
object's thread. In other words, all network IO is performed in one thread 
independently of used execution policy.

\subsection policy_list Available execution policies
Currently, libraray provides two execution policies:
 - Serial execution;
 - Execution in a pool of threads.
 
An example for creating Server with serial execution model:
\dontinclude tests/http_server.cc
\skip main()
\skipline Server

An example for creating Server with multithreaded execution model, using a
pool of 10 threads:
\dontinclude tests/http_server_thr.cc
\skip main()
\skipline Server
*/


/*!
\page introspection Server introspection
Libiqxmlrpc allows to create server application which allows clients 
request some help information its supported methods. This facility called 
introspection.

Please refer http://xmlrpc.usefulinc.com/doc/reserved.html
introspection's specification.

\subsection enable_introspeciton Enable introspection
One need call iqxmlrpc::Server::enable_introspection method to turn on 
introspection support in application.

\subsection provide_help Provide help informaion
It is not enough to just enable introspeciton for get things work. One must also
provide appropriate structures to make helper informaion available for clients.

It is more easy to describe an example of well created method class, which
contains introspeciton information:
\code
  class MyMethod: public iqxmlrpc::Method {
  public:
    class Help: public Method::Help {
      iqxmlrpc::Value signature() const;
      std::string help() const;
    };
    
    // ...  
  };
\endcode

According to this example one need create nested class Help in MyMethod.
It should be inherited form iqxmlrpc::Method::Help and reimplement virtual
"signature" and "help" methods to ensure introspeciton support for particular 
method class MyMethod.

\note Help::signature must return iqxmlrpc::Value formed according to 
introspecion specification.

\note If some method class does not contain nested Help class then library
would use iqxmlrpc::Method::Help class for introspection. It's signature and 
help methods return Nil and empty string respectively.
*/


/*!
\page fci_conformance Fault Code Interoperability
Libiqxmlrpc is 
<a href="http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php">FCI</a>
compatible.

So it returns FCI conformant fault codes and forbid users to return fault codes
in range [-32768, -32000] as FCI requires.
*/
